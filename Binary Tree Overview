#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <math.h>
#include <string>
#include <queue>
using namespace std;




struct node 
{
    char info;
    node *left;
    node *right;
};

void inorderTraversal(node  * p) ;   // print node data in order
void preorderTraversal(node  * p);  // print node data pre order
void postorderTraversal(node * p);  // print node data post order
void levelorderTraversal(node * p); // level order



int leafCount(node * p); // return number of leaves in p
int height(node * p);  // return height of p
int nodeCount(node * p);   // return number of nodes in p

string longestPath(node * p);  // a string containing the node info values of a longest path, root to leaf
string shortestPath(node * p); // a string containing the node info values of a shortest path, root to leaf

node * makeARandomTree(int maxHeight); // This one is written for you.
void deleteTree(node * p);  // delete all dynamically allocated memory for this tree
bool isFull(node * p); // return true iff p is a full tree
bool isComplete(node * p) ;  // return true iff p is a complete tree
void drawTree(node * p,  int indent = 0);  // draw the tree. Use condensed spacing if condense == true.
node *  addTrees(node * left, node * right, char c);   // create a new tree with root c.





int main() {
    cout << "Pick a seed for random number generator, or 0 for time(0): ";
    int seed;
    cin >> seed;
    srand(seed >= 0 ? seed : (unsigned int)(time(0))); 

    cout << "Execute memory leak test? (y/n): ";
    char response;
    cin >> response;
    if (response == 'y') {
        cout << "Starting memory leak test " << endl;
        for (int i = 0; i < 5; i++) {       
            node * p = makeARandomTree(3);    
            deleteTree(p); 
        }
        cout << "Done with memory leak test " << endl;
    }
    bool done = false;
    while (!done) {
        int maxHeight;
        cout << "maximum height? (or -2 to quit): ";
        cin >> maxHeight;
        if (maxHeight <= -1)
            done = true;
 else {  
          node * p = makeARandomTree(maxHeight);
          drawTree(p, 0);  
 
          cout << endl;
          cout << "\tHeight = " << height(p ) << ", Leafcount = "
               << leafCount(p) <<  ", NodeCount = " << nodeCount(p) << endl;
 
          cout <<    endl << "\tPre Order:     < ";
          preorderTraversal(p);
          cout << ">" << endl << endl << "\tIn Order:      < ";
          inorderTraversal(p);
          cout << ">" << endl <<endl <<  "\tPost Order:    < ";
          postorderTraversal(p);
          cout << ">" << endl <<endl <<  "\tLevel Order:   < ";
          levelorderTraversal(p);
          cout << ">" << endl << endl;
 
          cout << "\tShortest Path: < " << shortestPath(p) << ">" << endl << endl;
          cout << "\tLongest Path:  < " << longestPath(p)   << ">" << endl << endl;    
          cout << "\tThis tree " << (isFull(p) ? "is" : "is not" ) << " full. " << endl << endl;
          cout << "\tThis tree " << (isComplete(p) ? "is" : "is not" ) << " complete. " << endl << endl;      
 
          deleteTree(p);
       }  
    }
    cout << "Bye!" << endl;
    cin.get(); cin.get();
	system ("pause");
    return 0;
}

node * addTrees (node * left , node *right , char info ) 
{
	node * temp = new node;
	temp->info = info;
	temp->left = left;
	temp->right = right;
	return temp;
}

node * makeARandomTree(int height) {

    if (height <= 0) return NULL;

    node * p = rand() % 5 != 0 ? makeARandomTree(height-1) : NULL;
    node * q = rand() % 5 != 0 ? makeARandomTree(height-1) : NULL;
 
    return addTrees(p,q, char('A' + rand() % ('Z' - 'A' + 1)));
}
void drawTree(node * p, int indent)
{
	int dashes = 3;
	for (int i=0; i<indent; i++)		cout << ' ';	
	
	if (p!=NULL) {
		for (int i=0; i<dashes; i++)		cout <<'-';
		cout << p->info<<endl;
		drawTree(p->left,  indent+5);
		drawTree(p->right,  indent+5);
	} else{
		cout<< "~" << endl;
	}
}

void inorderTraversal(node  * p)
{
	if(p != NULL)
	{
		inorderTraversal(p->left);
		cout<<p->info;
		inorderTraversal(p->right);
	}
}

void preorderTraversal(node  * p)
{
	if(p != NULL)
	{
		cout<<p->info;
		preorderTraversal(p->left);
		preorderTraversal(p->right);
	}
}

void postorderTraversal(node  * p)
{
	if(p != NULL)
	{
		postorderTraversal(p->left);
		postorderTraversal(p->right);
		cout<<p->info;
	}
}

void levelorderTraversal(node * p)
{
	// Create a queue
   queue<node*> q;

   // Push the root
   q.push(p);

   while ( ! q.empty() )
   {
       // Dequeue a node from front
       node* v = q.front();
       cout << v->info << " ";

       // Enqueue the left children
       if ( v->left != NULL )
            q.push(v->left);

       // Enqueue the right children
       if ( v->right != NULL )
            q.push(v->right);

       // Pop the visited node
       q.pop();
   }
}

int height(node * p)
{
	if (p==NULL)
       return 0;
   else
   {
     /* compute the height of each subtree */
     int lheight = height(p->left);
     int rheight = height(p->right);
 
     /* use the larger one */
     if (lheight > rheight)
         return(lheight+1);
     else return(rheight+1);
   }
}

int nodeCount(node * p)
{
           // Count the nodes in the binary tree to which
           // root points, and return the answer.
        if ( p == NULL )
           return 0;  // The tree is empty.  It contains no nodes.
        else {
           int count = 1;   // Start by counting the root.
           count += nodeCount(p->left);  // Add the number of nodes
                                            //     in the left subtree.
           count += nodeCount(p->right); // Add the number of nodes
                                            //    in the right subtree.
           return count;  // Return the total.
        }
     } // end countNodes()

int leafCount(node * p)
{
	if(p == NULL)       
    return 0;
  if(p->left == NULL && p->right==NULL)      
    return 1;            
  else
    return leafCount(p->left) + leafCount(p->right);    
}

string longestPath(node * p)  // a string containing the node info values of a longest path, root to leaf
{
	string path;
	if(p == NULL){ return 0;}
	
    else 
	{
		while(p != NULL)
		{
        if(height(p->left) > height(p->right))
		{
			path = path + p->info;
			p = p->left;
		}
		else
		{
			path = path + p->info;
			p = p->right;
		}
		}
		return path;
	}

}       

string shortestPath(node * p)  // a string containing the node info values of a longest path, root to leaf
{
	string path;
	if(p == NULL){ return 0;}
	
    else 
	{
		while(p != NULL)
		{
        if(height(p->left) < height(p->right))
		{
			path = path + p->info;
			p = p->left;
		}
		else
		{
			path = path + p->info;
			p = p->right;
		}
		}
		return path;
	}


}       

void deleteTree(node * p)  // delete all dynamically allocated memory for this tree
{
	if(p != NULL)
	{
		deleteTree(p->left);
		deleteTree(p->right);
		delete p;
		p = NULL;
	}
}

bool isFull(node * p) // return true iff p is a full tree
{
	if(p == NULL) return true;
	else
	{
		int nleaves = leafCount(p);
		int h = height(p) - 1;
		double ideal = pow(2.0, h);
		if(ideal != nleaves)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	
}


bool isComplete(node * p) // return true iff p is a complete tree
{
	if(p == NULL) return true;
	else if(isFull(p)) return true;
	else
	{
		int nnodes = nodeCount(p);
		int h = height(p);
		int minR = pow(2.0, h - 1);
		int maxR = pow(2.0, h) - 1;
		if( nnodes >= minR && nnodes <= maxR)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
}
